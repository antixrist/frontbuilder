import { API_URL } from '../../config';
import { progress, http } from '../';
import { errorToJSON } from '../../utils';

const api = http.create({
  method: 'post',
  baseURL: API_URL,
  headers: {
    'Accept':       'application/json',
    'Content-Type': 'application/json',
  },
});

/**
 * Прогресс для запросов к api
 */

api.interceptors.request.use(
  config => {
    /**
     * если передать { silent: true } в параметрах запроса,
     * то прогресс для этого запроса показан не будет
     */
    !config.silent && progress.requestStart();

    return config;
  },
  err => {
    const { isCanceled, config } = err;

    if (!config || !config.silent) {
      progress.requestDone();
    }

    return Promise.reject(err);
  }
);

api.interceptors.response.use(
  res => {
    const { config } = res;
    !config.silent && progress.requestStart();

    return res;
  },
  err => {
    if (!err.isCanceled) {
      const { config } = err;
      if (!config || !config.silent) {
        progress.requestDone();
      }
    }

    let retVal;
    if (err.CLIENT_ERROR) {
      const { response: { data } } = err;

      switch (err.code) {
        // case 401:
        //   break;
        // case 403:
        //   break;
        // case 404:
        //   break;
        // case 500:
        //   break;
        // case 800: // wtf?
        //   break;

        // ошибки валидации
        case 422:
          retVal = {
            data,
            success: false,
            message: err.message,
            code: err.code
          };
        break;
      }
    }

    return retVal ? retVal : Promise.reject(err);
  }
);

export default api;

export async function reportError (data, opts = {}) {
  const { error } = data;
  const errObj = errorToJSON(error);
  delete data.error;

  errObj.stackframes && errObj.stackframes.map(sf => sf.toString()).join('\n');

  Object.assign(data, errObj, {
    userAgent: navigator.userAgent,
    location: document.location.href,
  });

  return await api.post('/report-error', data, Object.assign({
    silent: true
  }, opts)).catch(err => console.error(err));
}


// http.interceptors.response.use(
//   response => response,
//   error => {
//     /**
//      * This is a central point to handle all
//      * error messages generated by HTTP
//      * requests
//      */
//     const { response } = error;
//     /**
//      * If token is either expired, not provided or invalid
//      * then redirect to login. On server side the error
//      * messages can be changed on app/Providers/EventServiceProvider.php
//      */
//     if ([401, 400].indexOf(response.status) > -1) {
//       router.push({ name: 'login.index' });
//     }
//     /**
//      * Error messages are sent in arrays
//      */
//     if (isArray(response.data)) {
//       store.dispatch('setMessage', { type: 'error', message: response.data.messages });
//       /**
//        * Laravel generated validation errors are
//        * sent in an object
//        */
//     } else {
//       store.dispatch('setMessage', { type: 'validation', message: response.data });
//     }
//
//     store.dispatch('setFetching', { fetching: false });
//
//     return Promise.reject(error);
//   }
// );

// let instance = axios.create({
//   baseUrl: ''
// });
//
// _.assign(instance.defaults.headers.common, {
//   Accept: 'application/json',
//   'Content-Type': 'application/json'
// });
//
// instance.interceptors.request.use(req => {
//   progress.start();
//
//   const token = ls.get('token') || 'blablablabla';
//   token && (req.headers['X-HTTP-TOKEN'] = token);
//
//   return req;
// }, err => {
//   progress.done(true);
//
//   return Promise.reject(error)
// });
// instance.interceptors.response.use(res => {
//   progress.done(true);
//
//   const token = res.headers['Authorization'] || res.data['token'];
//   token && ls.set('token', token);
//
//   return res;
// }, err => {
//   progress.done(true);
//
//   return Promise.reject(err)
// });
//
// export default instance;
