import _ from 'lodash';
import { API_URL } from '../config';
import { http } from '../services';
import { errorToJSON } from '../utils';
import progress, { ProgressStack } from '../services/progress';

const api = http.create({
  method: 'post',
  baseURL: API_URL,
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  },
  data: {}
});

/** Прогресс для запросов к api */
const apiRequestsProgress = new ProgressStack();
apiRequestsProgress.setProgress(progress);

api.interceptors.request.use(config => {
  /**
   * если передать { silent: true } в параметрах запроса,
   * то прогресс для этого запроса показан не будет
   */
  // !config.silent && apiRequestsProgress.add(config);

  return config;
}, err => {
  // apiRequestsProgress.done(err.config);

  return Promise.reject(err);
});
api.interceptors.response.use(res => {
  // apiRequestsProgress.done(res.config);

  return res;
}, err => {
  // apiRequestsProgress.done(err.config);

  // глушим ошибки, если запрос был отменён токеном отмены
  if (err.isCanceled) { return true; }

  let retVal;
  if (err.CLIENT_ERROR) {
    const { response: { data } } = err;

    switch (err.code) {
      // case 401:
      //   break;
      // case 403:
      //   break;
      // case 404:
      //   break;
      // case 500:
      //   break;
      // case 800: // wtf?
      //   break;

      // ошибки валидации
      case 422:
        retVal = {
          data,
          success: false,
          message: err.message,
          code: err.code
        };
      break;
    }
  }

  return retVal ? retVal : Promise.reject(err);
});




window.api = api;
window.errorToJSON = errorToJSON;

export default api;

export async function reportError (data, opts = {}) {
  const { error } = data;
  const errObj = errorToJSON(error);
  delete data.error;

  errObj.stackframes && errObj.stackframes.map(sf => sf.toString()).join('\n');

  Object.assign(data, errObj, {
    userAgent: navigator.userAgent,
    location: document.location.href,
  });

  return await api.post('/report-error', data, Object.assign({
    silent: true
  }, opts)).catch(err => console.error(err));
}


// http.interceptors.response.use(
//   response => response,
//   error => {
//     /**
//      * This is a central point to handle all
//      * error messages generated by HTTP
//      * requests
//      */
//     const { response } = error;
//     /**
//      * If token is either expired, not provided or invalid
//      * then redirect to login. On server side the error
//      * messages can be changed on app/Providers/EventServiceProvider.php
//      */
//     if ([401, 400].indexOf(response.status) > -1) {
//       router.push({ name: 'login.index' });
//     }
//     /**
//      * Error messages are sent in arrays
//      */
//     if (isArray(response.data)) {
//       store.dispatch('setMessage', { type: 'error', message: response.data.messages });
//       /**
//        * Laravel generated validation errors are
//        * sent in an object
//        */
//     } else {
//       store.dispatch('setMessage', { type: 'validation', message: response.data });
//     }
//
//     store.dispatch('setFetching', { fetching: false });
//
//     return Promise.reject(error);
//   }
// );

// let instance = axios.create({
//   baseUrl: ''
// });
//
// _.assign(instance.defaults.headers.common, {
//   Accept: 'application/json',
//   'Content-Type': 'application/json'
// });
//
// instance.interceptors.request.use(req => {
//   progress.start();
//
//   const token = ls.get('token') || 'blablablabla';
//   token && (req.headers['X-HTTP-TOKEN'] = token);
//
//   return req;
// }, err => {
//   progress.done(true);
//
//   return Promise.reject(error)
// });
// instance.interceptors.response.use(res => {
//   progress.done(true);
//
//   const token = res.headers['Authorization'] || res.data['token'];
//   token && ls.set('token', token);
//
//   return res;
// }, err => {
//   progress.done(true);
//
//   return Promise.reject(err)
// });
//
// export default instance;
