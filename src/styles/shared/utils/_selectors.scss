@import '~sassdash/index';
@import '~sassy-strings/stylesheets/SassyStrings';

/// @access private
/// @param  {String}  $selector
/// @return {String}  $selector
@function selector-to-string ($selector) {
  $list-separator: list-separator($selector);

  @if type_of($selector == list) {
    $selector: unquote(inspect($selector)); //cast to string
    //@if $list-separator == comma {
    //  $selector: str-slice($selector, 2, -2); //remove brackets
    //}
  }

  @return $selector;
}

// Парсит входные параметры и возвращает comma-лист с селекторами
@function parse-selectors ($items...) {
  $retVal: ();

  @each $item in $items {
    @if _is-list-like($item) {
      @if list-separator($item) == comma {
        @each $selector in $item {
          $retVal: join($retVal, parse-selectors($selector), comma);
        }
      } @else {
        $has-comma: str-index(inspect($item), ',') != null;
        @if $has-comma == true {
          @each $selector in $item {
            $retVal: join($retVal, parse-selectors($selector), comma);
          }
        } @else {
          $retVal: append($retVal, _map($item, _trim), comma);
        }
      }
    } @else {
      $has-comma: str-index(inspect($item), ',') != null;
      @if $has-comma == true {
        @each $selector in _split($item, ',') {
          $retVal: join($retVal, parse-selectors($selector), comma);
        }
      } @else {
        $item: unquote($item);
        $item: _trim($item);
        $retVal: append($retVal, $item, comma);
      }
    }
  }

  @return $retVal;
}

@function selector-rules ($selector) {
  $rules: if(_is-list($selector), $selector, _split($selector, ' '));
  @return _map($rules, unquote);
}

@function rule-states ($rule) {
  $states: _split($rule, ':');
  @if (length($states) > 0) {
    $states: _drop($states);
    $states: _map($states, _trim);
    $states: _compact($states);
    $states: _difference($states, (before, after));
  }

  @return $states;
}

@function rule-has-states ($rule) {
  @return length(rule-states($rule)) > 0;
}

@function selector-has-states ($selector) {
  @each $rule in selector-rules($selector) {
    @if (rule-has-states($rule) == true) {
      @return true;
    }
  }

  @return false;
}

@function rule-without-states ($rule) {
  $splitted: _split($rule, ':');
  $splitted: _intersection($splitted, (_first($splitted), before, after));
  $rule: _join($splitted, ':');

  @return $rule;
}

@function rule-without-filters ($rule) {
  @return _first(_split($rule, ':'));
}

@mixin sibling-self (
  /** todo: */
  $attrs: false,
  $states: false
) {
  $selectors: ();

  @each $selector in parse-selectors(&) {
    $rules: selector-rules($selector);
    $rule: _last($rules);
    $rule: rule-without-states($rule);

    $selectors: append($selectors, '#{$selector} + #{$rule}', comma);
  }

  $selectors: _uniq($selectors);

  @at-root #{$selectors} {
    @content;
  }
}

@function get-states-string ($states) {
  $states: if(_is-list($states), $states, ($states,));
  $states: if(length($states) > 0, ':#{_join($states, ':')}', '');

  @return $states;
}

@function cleanup-rule ($rule) {
  $rule-states: rule-states($rule);
  $rule: rule-without-filters($rule);

  $new-rule-states: ();
  @each $rule-state in $rule-states {
    $idx-start: str-last-index($rule-state, '[');
    $idx-end: str-last-index($rule-state, ']');

    @while $idx-start != null and $idx-end != null {
      $rule: $rule + str-slice($rule-state, $idx-start, $idx-end);
      $rule-state: str-slice($rule-state, 0, $idx-start - 1) + str-slice($rule-state, $idx-end + 1);

      $idx-start: str-last-index($rule-state, '[');
      $idx-end: str-last-index($rule-state, ']');
    }

    $new-rule-states: append($new-rule-states, $rule-state);
  }

  @return '#{$rule}#{get-states-string($new-rule-states)}';
}

@function cleanup-selectors ($selectors...) {
  $new-selectors: ();
  $selectors: parse-selectors($selectors);

  @each $selector in $selectors {
    $new-selector: ();
    $rules: selector-rules($selector);

    @each $rule in $rules {
      $new-rule: cleanup-rule($rule);
      $new-selector: append($new-selector, $new-rule, space);
    }

    $new-selectors: append($new-selectors, $new-selector, comma);
  }

  @return $new-selectors;
}

// Повышает специфичность
// `.className` => `.className.className`
// осторожно! `h1` => `h1h1`
@mixin power () {
  $selectors: ();

  @each $selector in & {
    $current: _last($selector);
    $parents: _drop-right($selector, 1);

    $splitted: _split($current, ':');

    $current: nth($splitted, 1);
    $power: if($current != '*', $current, '');

    $states: _drop($splitted, 1);
    $states: _join($states, ':');
    $states: if($states != '' and $states != null, ':#{$states}', null);

    $selectors: append($selectors, #{$parents} #{$power}#{$current}#{$states}, comma);
  }

  @at-root #{$selectors} {
    @content;
  }
}

/**
 * Return a list of all of the rules within the selector
 */
@function rules ($selector) {
  @return _split(_trim(selector-to-string($selector)), ' ');
}

/**
 * For each of the given elements, create a combined rule, applying the given
 * prefix.
 */
@function combined-rule ($prefix, $elements) {
  $rules: ();
  @each $element in $elements {
    $rules: append($rules, unquote($prefix + $element), comma);
  }
  @return $rules;
}
