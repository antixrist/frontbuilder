@import '~sassdash/index';
@import '~sassy-strings/stylesheets/SassyStrings';

/// @access private
/// @param  {String}  $selector
/// @return {String}  $selector
@function selector-to-string ($selector) {
  $list-separator: list-separator($selector);

  @if type_of($selector == list) {
    $selector: unquote(inspect($selector)); //cast to string
    //@if $list-separator == comma {
    //  $selector: str-slice($selector, 2, -2); //remove brackets
    //}
  }

  @return $selector;
}

// Парсит входные параметры и возвращает comma-лист с селекторами
@function parse-selectors ($items...) {
  $retVal: ();

  @each $item in $items {
    @if _is-list-like($item) {
      @if list-separator($item) == comma {
        @each $selector in $item {
          $retVal: join($retVal, parse-selectors($selector), comma);
        }
      } @else {
        $has-comma: str-index(inspect($item), ',') != null;
        @if $has-comma == true {
          @each $selector in $item {
            $retVal: join($retVal, parse-selectors($selector), comma);
          }
        } @else {
          $retVal: append($retVal, _map($item, _trim), comma);
        }
      }
    } @else {
      $has-comma: str-index(inspect($item), ',') != null;
      @if $has-comma == true {
        @each $selector in _split($item, ',') {
          $retVal: join($retVal, parse-selectors($selector), comma);
        }
      } @else {
        $item: unquote($item);
        $item: _trim($item);
        $retVal: append($retVal, $item, comma);
      }
    }
  }

  @return $retVal;
}

@function selector-rules ($selector) {
  $rules: if(_is-list($selector), $selector, _split($selector, ' '));
  @return _map($rules, unquote);
}

@function rule-states ($rule) {
  $states: _split($rule, ':');
  @if (length($states) > 0) {
    $states: _drop($states);
    $states: _map($states, _trim);
    $states: _compact($states);
    $states: _difference($states, (before, after));
  }

  @return $states;
}

@function _parse-str-attrs ($str) {
  $attrs: ();
  $idx-start: str-last-index($str, '[');
  $idx-end: str-last-index($str, ']');

  @while $idx-start != null and $idx-end != null {
    $attrs: append($attrs, str-slice($str, $idx-start, $idx-end), comma);
    $str: str-slice($str, 0, $idx-start - 1) + str-slice($str, $idx-end + 1);

    $idx-start: str-last-index($str, '[');
    $idx-end: str-last-index($str, ']');
  }

  @return (
    str: $str,
    attrs: $attrs
  );
}


@function stringify-states ($states) {
  $states: if(_is-list($states), $states, ($states,));
  $states: if(length($states) > 0, ':#{_join($states, ':')}', '');

  @return $states;
}

@function _parse-rule ($rule) {
  $attrs: ();
  $states: ();

  $splitted: _split($rule, ':');
  @if (length($splitted) > 1) {
    $states: _drop($splitted);
    $states: _map($states, _trim);
    $states: _compact($states);
    $rule: _first($splitted);
  }

  $_states: ();
  @each $state in $states {
    @if _ends-with($state, ']') {
      $tmp: _parse-str-attrs($state);
      $state: map-get($tmp, 'str');
      $attrs: join($attrs, map-get($tmp, 'attrs'), comma);
    }
    $_states: append($_states, $state, comma);
  }
  $states: $_states;

  $tmp: _parse-str-attrs($rule);
  $rule: map-get($tmp, 'str');
  $attrs: join($attrs, map-get($tmp, 'attrs'), comma);

  $attrs: _map($attrs, unquote);
  $states: _map($states, unquote);

  @return (
    rule: $rule,
    attrs: $attrs,
    states: $states
  );
}

@function parse-rule ($rule) {
  $attrs: ();
  $states: ();

  $rule: _replace($rule, '::after', ':after');
  $rule: _replace($rule, '::before', ':before');

  $before: null;
  $after: null;

  $tmp: _split($rule, ':before');
  @if length($tmp) > 1 {
    $before: _last($tmp);
    $rule: _join(_drop-right($tmp, 1), '');
    $before: _parse-rule('BEFORE#{$before}');
  }

  $tmp: _split($rule, ':after');
  @if length($tmp) > 1 {
    $after: _last($tmp);
    $rule: _join(_drop-right($tmp, 1), '');
    $after: _parse-rule('AFTER#{$after}');
  }

  $rule: _parse-rule($rule);

  @if ($before != null) {
    $rule: _set($rule, 'attrs', join(_get($rule, 'attrs'), _get($before, 'attrs'), comma));
    $before: _set($before, 'rule', unquote(':before'));
    $before: map-remove($before, 'attrs');
  }

  @if ($after != null) {
    $rule: _set($rule, 'attrs', join(_get($rule, 'attrs'), _get($after, 'attrs'), comma));
    $after: _set($after, 'rule', unquote(':before'));
    $after: map-remove($after, 'attrs');
  }

  $rule: _set($rule, 'attrs', _uniq(_get($rule, 'attrs')));
  $rule: _set($rule, 'states', _uniq(_get($rule, 'states')));

  $rule: _set($rule, before, $before);
  $rule: _set($rule, after, $after);

  @return $rule;
}

@function stringify-rule ($rule) {
  $attrs: map-get($rule, 'attrs');
  $states: map-get($rule, 'states');
  $before: map-get($rule, 'before');
  $after: map-get($rule, 'after');
  $rule: map-get($rule, 'rule');

  $retVal: '#{$rule}#{_join($attrs)}#{stringify-states($states)}';

  @if $before != null {
    $rule: map-get($before, 'rule');
    $states: map-get($before, 'states');

    $retVal: '#{$retVal}#{$rule}#{stringify-states($states)}';
  }
  @if $after != null {
    $rule: map-get($after, 'rule');
    $states: map-get($after, 'states');

    $retVal: '#{$retVal}#{$rule}#{stringify-states($states)}';
  }

  @return $retVal;
}

@function rule-has-states ($rule) {
  @return length(rule-states($rule)) > 0;
}

@function selector-has-states ($selector) {
  @each $rule in selector-rules($selector) {
    @if (rule-has-states($rule) == true) {
      @return true;
    }
  }

  @return false;
}

@function rule-without-states (
  $rule,
  $whitelist: (before, after)
) {
  $splitted: _split($rule, ':');
  @if (_is-list($whitelist) and length($whitelist) > 1) {
    $splitted: _intersection($splitted, join((_first($splitted),), $whitelist));
  }
  $rule: _join($splitted, ':');

  @return $rule;
}

@mixin sibling-self (
  /** todo: */
  $attrs: false,
  $states: false
) {
  $selectors: ();

  @each $selector in parse-selectors(&) {
    $rules: selector-rules($selector);
    $rule: _last($rules);
    $rule: rule-without-states($rule);

    $selectors: append($selectors, '#{$selector} + #{$rule}', comma);
  }

  $selectors: _uniq($selectors);

  @at-root #{$selectors} {
    @content;
  }
}

@function get-states-string ($states) {
  $states: if(_is-list($states), $states, ($states,));
  $states: if(length($states) > 0, ':#{_join($states, ':')}', '');

  @return $states;
}

@function cleanup-rule ($rule) {
  $rule-states: rule-states($rule);
  $rule: rule-without-states($rule, $whitelist: null);

  $new-rule-states: ();
  @each $rule-state in $rule-states {
    $idx-start: str-last-index($rule-state, '[');
    $idx-end: str-last-index($rule-state, ']');

    @while $idx-start != null and $idx-end != null {
      $rule: $rule + str-slice($rule-state, $idx-start, $idx-end);
      $rule-state: str-slice($rule-state, 0, $idx-start - 1) + str-slice($rule-state, $idx-end + 1);

      $idx-start: str-last-index($rule-state, '[');
      $idx-end: str-last-index($rule-state, ']');
    }

    $new-rule-states: append($new-rule-states, $rule-state);
  }

  @return '#{$rule}#{get-states-string($new-rule-states)}';
}

@function cleanup-selectors ($selectors...) {
  $new-selectors: ();
  $selectors: parse-selectors($selectors);

  @each $selector in $selectors {
    $new-selector: ();
    $rules: selector-rules($selector);

    @each $rule in $rules {
      $new-rule: cleanup-rule($rule);
      $new-selector: append($new-selector, $new-rule, space);
    }

    $new-selectors: append($new-selectors, $new-selector, comma);
  }

  @return $new-selectors;
}

// Повышает специфичность
// `.className` => `.className.className`
// осторожно! `h1` => `h1h1`
@mixin power () {
  $selectors: ();

  @each $selector in & {
    $current: _last($selector);
    $parents: _drop-right($selector, 1);

    $splitted: _split($current, ':');

    $current: nth($splitted, 1);
    $power: if($current != '*', $current, '');

    $states: _drop($splitted, 1);
    $states: _join($states, ':');
    $states: if($states != '' and $states != null, ':#{$states}', null);

    $selectors: append($selectors, #{$parents} #{$power}#{$current}#{$states}, comma);
  }

  @at-root #{$selectors} {
    @content;
  }
}

/**
 * Return a list of all of the rules within the selector
 */
@function rules ($selector) {
  @return _split(_trim(selector-to-string($selector)), ' ');
}

/**
 * For each of the given elements, create a combined rule, applying the given
 * prefix.
 */
@function combined-rule ($prefix, $elements) {
  $rules: ();
  @each $element in $elements {
    $rules: append($rules, unquote($prefix + $element), comma);
  }
  @return $rules;
}
